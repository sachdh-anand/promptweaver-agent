from fastapi import FastAPI, HTTPException, Body, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any, Union
from enum import Enum
from uuid import uuid4
import json
import os
import time
import asyncio
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Import the actual CrewAI integration
try:
    from src.crew import run_prompt_weaver_crew
    logger.info("Successfully imported run_prompt_weaver_crew function from src.crew")
except ImportError:
    try:
        # Try alternative import if the first one fails
        from crew import run_prompt_weaver_crew
        logger.info("Successfully imported run_prompt_weaver_crew function from crew")
    except ImportError:
        logger.error("Failed to import run_prompt_weaver_crew! Using fallback implementation.")
        
        # Fallback implementation if imports fail
        def run_prompt_weaver_crew(instruction: str) -> str:
            """Fallback implementation when crew.py is not available"""
            logger.warning(f"Using fallback implementation for prompt: {instruction[:50]}...")
            return f"""# {instruction.title()}

## Objective
Provide detailed information about {instruction}.

## Context
This prompt was generated by the fallback implementation, as the main CrewAI integration could not be loaded.

## Instructions
1. Define key terms
2. Explain core concepts
3. Provide relevant examples
4. Address potential questions

## Constraints
- Be accurate and precise
- Use clear language
- Maintain proper structure
"""

app = FastAPI(title="PromptWeaver A2A API")

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # For development - restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files - this is where we'll serve the agent.json
os.makedirs("./.well-known", exist_ok=True)
app.mount("/.well-known", StaticFiles(directory=".well-known"), name="well-known")

# A2A Protocol Models
class TaskState(str, Enum):
    SUBMITTED = "submitted"
    WORKING = "working"
    INPUT_REQUIRED = "input-required"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELED = "canceled"

class MessageRole(str, Enum):
    USER = "user"
    AGENT = "agent"

class OperatingMode(str, Enum):
    LEAN = "lean"
    FULL = "full"

class Part(BaseModel):
    type: str 
    text: Optional[str] = None
    form: Optional[Dict[str, Any]] = None
    data: Optional[Dict[str, Any]] = None

class Message(BaseModel):
    role: MessageRole
    parts: List[Part]
    
class TaskRequestParams(BaseModel):
    mode: Optional[OperatingMode] = OperatingMode.LEAN
    description: str

class TaskRequest(BaseModel):
    id: Optional[str] = None
    message: Message

class Task(BaseModel):
    id: str
    state: TaskState
    messages: List[Message] = []
    created_at: str
    updated_at: str
    parameters: Optional[Dict[str, Any]] = None

# In-memory storage for tasks
tasks_db = {}

# Set environment variables based on mode
async def set_mode_environment(mode: OperatingMode):
    """Set environment variables based on the selected mode"""
    if mode == OperatingMode.LEAN:
        os.environ["USE_LEAN_MODE"] = "true"
        logger.info("Setting environment to LEAN mode")
    else:
        os.environ["USE_LEAN_MODE"] = "false"
        logger.info("Setting environment to FULL mode")
    
    # You can set additional environment variables here if needed
    # os.environ["CREWAI_VERBOSE"] = "true"  # Uncomment to enable verbose CrewAI logs

# PromptWeaver crew execution
async def run_promptweaver(task_id: str, description: str, mode: OperatingMode):
    """
    Runs the PromptWeaver crew to generate a prompt.
    This integrates with the actual crew.py implementation.
    """
    try:
        # Update task state to working
        tasks_db[task_id]["state"] = TaskState.WORKING
        tasks_db[task_id]["updated_at"] = datetime.now().isoformat()
        
        # Set the environment based on mode
        await set_mode_environment(mode)
        
        # Log the start of execution with more context
        logger.info(f"Starting PromptWeaver crew execution for task {task_id}")
        logger.info(f"Mode: {mode.value}, Description: {description[:100]}...")
        
        # Actual call to the CrewAI implementation
        prompt_result = run_prompt_weaver_crew(description)
        logger.info(f"CrewAI execution completed for task {task_id}")
        
        # Check for error response
        if prompt_result.startswith("Error:"):
            logger.error(f"CrewAI execution failed: {prompt_result}")
            tasks_db[task_id]["state"] = TaskState.FAILED
            agent_message = Message(
                role=MessageRole.AGENT,
                parts=[
                    Part(
                        type="text",
                        text=f"Failed to generate prompt: {prompt_result}"
                    )
                ]
            )
        else:
            # Create successful agent response message
            agent_message = Message(
                role=MessageRole.AGENT,
                parts=[
                    Part(
                        type="text",
                        text=f"Here's your optimized prompt:\n\n{prompt_result}"
                    )
                ]
            )
            tasks_db[task_id]["state"] = TaskState.COMPLETED
        
        # Update task with the result
        tasks_db[task_id]["messages"].append(agent_message)
        tasks_db[task_id]["updated_at"] = datetime.now().isoformat()
        
    except Exception as e:
        logger.exception(f"Exception during PromptWeaver execution: {e}")
        
        # Update task to failed state with error message
        tasks_db[task_id]["state"] = TaskState.FAILED
        error_message = Message(
            role=MessageRole.AGENT,
            parts=[
                Part(
                    type="text",
                    text=f"An error occurred while generating the prompt: {str(e)}"
                )
            ]
        )
        tasks_db[task_id]["messages"].append(error_message)
        tasks_db[task_id]["updated_at"] = datetime.now().isoformat()

# A2A Protocol Endpoints
@app.post("/a2a", response_model=Dict[str, Any])
async def handle_jsonrpc(request: Dict[str, Any] = Body(...)):
    """
    Main JSON-RPC 2.0 handler for A2A protocol
    """
    if not isinstance(request, dict):
        raise HTTPException(status_code=400, detail="Invalid JSON-RPC request")
    
    method = request.get("method")
    params = request.get("params", {})
    id = request.get("id")
    
    if method == "tasks/send":
        return await handle_tasks_send(params, id)
    elif method == "tasks/get":
        return await handle_tasks_get(params, id)
    elif method == "tasks/cancel":
        return await handle_tasks_cancel(params, id)
    else:
        return {
            "jsonrpc": "2.0",
            "error": {"code": -32601, "message": f"Method {method} not found"},
            "id": id
        }

async def handle_tasks_send(params: Dict[str, Any], id: Any):
    """
    Handle tasks/send method to create or update a task
    """
    try:
        # Parse request
        task_request = TaskRequest(**params)
        task_id = task_request.id or str(uuid4())
        
        # Extract parameters
        user_message = task_request.message
        
        # Process user message to get task parameters
        if user_message.role != MessageRole.USER:
            raise ValueError("Initial message must have 'user' role")
        
        # Extract description from user message
        description = None
        mode = OperatingMode.LEAN  # Default mode
        
        for part in user_message.parts:
            if part.type == "text":
                description = part.text
            elif part.type == "data" and part.data:
                if "mode" in part.data:
                    mode = OperatingMode(part.data["mode"])
        
        if not description:
            raise ValueError("User message must contain a text part")
        
        # Log the received task
        logger.info(f"Received task: ID={task_id}, Mode={mode.value}")
        logger.info(f"Description: {description[:100]}...")
        
        # Create or update task
        if task_id not in tasks_db:
            # Create new task
            task = {
                "id": task_id,
                "state": TaskState.SUBMITTED,
                "messages": [user_message],
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "parameters": {"mode": mode.value, "description": description}
            }
            tasks_db[task_id] = task
            
            # Process the task asynchronously
            asyncio.create_task(run_promptweaver(task_id, description, mode))
        else:
            # Update existing task
            tasks_db[task_id]["messages"].append(user_message)
            tasks_db[task_id]["updated_at"] = datetime.now().isoformat()
        
        # Return the task
        return {
            "jsonrpc": "2.0",
            "result": tasks_db[task_id],
            "id": id
        }
    
    except Exception as e:
        logger.exception(f"Error handling tasks/send: {e}")
        return {
            "jsonrpc": "2.0",
            "error": {"code": -32000, "message": str(e)},
            "id": id
        }

async def handle_tasks_get(params: Dict[str, Any], id: Any):
    """
    Handle tasks/get method to retrieve a task
    """
    try:
        task_id = params.get("id")
        if not task_id or task_id not in tasks_db:
            raise ValueError(f"Task {task_id} not found")
        
        return {
            "jsonrpc": "2.0",
            "result": tasks_db[task_id],
            "id": id
        }
    
    except Exception as e:
        logger.exception(f"Error handling tasks/get: {e}")
        return {
            "jsonrpc": "2.0",
            "error": {"code": -32000, "message": str(e)},
            "id": id
        }

async def handle_tasks_cancel(params: Dict[str, Any], id: Any):
    """
    Handle tasks/cancel method to cancel a task
    """
    try:
        task_id = params.get("id")
        if not task_id or task_id not in tasks_db:
            raise ValueError(f"Task {task_id} not found")
        
        if tasks_db[task_id]["state"] in [TaskState.COMPLETED, TaskState.FAILED, TaskState.CANCELED]:
            raise ValueError(f"Task {task_id} is already in terminal state")
        
        tasks_db[task_id]["state"] = TaskState.CANCELED
        tasks_db[task_id]["updated_at"] = datetime.now().isoformat()
        
        return {
            "jsonrpc": "2.0",
            "result": tasks_db[task_id],
            "id": id
        }
    
    except Exception as e:
        logger.exception(f"Error handling tasks/cancel: {e}")
        return {
            "jsonrpc": "2.0",
            "error": {"code": -32000, "message": str(e)},
            "id": id
        }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)